> 해당 글은 소프트웨어 마에스트로 15기 과정에서 진행 중인 대학생을 위한 설문조사 서비스 "[설문이용](http://sulmoon.io)"을 개발하며 겪은 경험을 정리한 것입니다.


## 0️⃣ 배경 - 설문 클래스를 어떻게 설계해야할까?

이전에 프로젝트를 진행했을 때는 설계 단계에서 큰 고민을 하지 않았다. 그러다 보니 기능이 추가될 수록 예상치 못한 버그가 이곳 저곳에서 발생하게 되었다.

그래서, 이번에 설문이용을 개발할 때는 **명확한 목표**를 정하고, **목표에 맞는 설계**를 해야겠다는 다짐을 하게되었다.

## 1️⃣ 효율적인 설계 & 구현 방법 찾기

### ▶️ 목표 설정 - 2달 내로 MVP 배포, 수집한 피드백을 바탕으로 개선

설계에 앞서 우리팀은 아래와 같이 목표를 설정했다.

1. **중간 발표 전 까지(2달 내로) MVP를 배포**한다.
2. 배포한 **MVP를 통해 피드백을 수집**하고, 이를 바탕으로 중간 발표를 준비한다.
3. 중간 발표 이후 수집한 **피드백을 바탕으로 서비스를 개선**한다.

### ▶️ 요구사항 정리 - MVP 까지 구현할 기능 요구사항 정리

앞으로의 설계 및 구현 계획을 세우기 위해 아래와 같은 형식으로 요구사항을 정리했다.

- `ex1: 사용자는 설문에 응답을 제출할 수 있다.`
- `ex2: 객관식 질문에 대한 응답은 선택지에 속해있어야한다.`

### ▶️ 설계 & 구현 계획 - 설계(DDD), 구현 및 개선(TDD)

우리 팀은 요구사항을 바탕으로 2달은 요구사항을 전부 구현하기에 충분한 기간이라고 판단했다.

그러므로 **단순히 구현을 빠르게 하기보단, 추후 요구사항 변경으로 인한 수정에 대비하는 것에 중점**을 두었다.

그리하여, 유지보수성 향상을 위해 **도메인 주도 개발**(DDD) 방식을 도입하여 설계를 진행하고, 안정성 향상을 위해 **테스트 주도 개발**(TDD) 방식을 도입하여 구현 및 개선을 진행하기로 결정하였다.

상세한 과정은 아래와 같다.

1. **DDD의 주요 개념들을 적용하여 설문 관련 도메인 클래스들을 설계한다.**
2. **요구사항에 맞는 테스트 코드를 작성한다.**
3. **테스트 코드를 만족하도록 클래스를 구현한다.**
4. **지속적인 리팩토링을 통해 코드 품질을 개선한다.**

### ▶️ 구현 결과

![image](https://github.com/user-attachments/assets/c63c77c2-85a0-4a18-83aa-bd923fc24501)

[**구현 과정이 담긴 PR 링크**](https://github.com/SUIN-BUNDANG-LINE/Backend/pull/9)

## 2️⃣ 설문 도메인 설계 과정 및 성과 (feat. DDD)

### ▶️ 설문 도메인 설명

![설문 구조](https://github.com/user-attachments/assets/40f71d25-bac7-4afb-b542-b1ba13cbef25)

설계할 설문 도메인을 살펴보면, 하나의 설문에는 여러개의 섹션이, 하나의 섹션에는 여러개의 질문이 있는 형태이다.

![image](https://github.com/user-attachments/assets/c88627a8-519b-418b-a0e0-e49f7f532276)

또한, 사용자는 설문에 참여해서 응답을 제출할 수 있고, 위와 같이 응답에 따라 다른 섹션으로 이동할 수 있도록 라우팅 설정 기능을 제공한다.

### ▶️ 어떻게 DDD 방식을 설문에 적용했는가?

![image](https://github.com/user-attachments/assets/afc75373-a665-4f8b-9a0f-48ccfd0024e4)

설문 도메인의 요구사항들을 바탕으로 위와 같이 설문 도메인 클래스들을 설계하였다.

DDD의 주요 개념 중 하나인 Aggregate를 도입하여, 설문과 관련된 객체를 하나의 설문 Aggregate로 묶었다.

또한, 설문 Aggregate root를 `Survey`로 설정하여 하위 객체에 직접 접근하지 못하도록 하여 하위 객체를 캡슐화하고, 예상치 못한 변경을 막았다.

```kotlin
data class Survey(
    val id: UUID,
    val title: String,
    val sections: List<Section>,
    // 그 외의 속성들
) {
		// Survey Class 생성 시 유효성 검증 진행
    init {
        require(sections.isNotEmpty()) { throw InvalidSurveyException() }
        require(isSectionsUnique()) { throw InvalidSurveyException() }
        require(isSurveyStatusValid()) { throw InvalidSurveyException() }
        require(isFinishedAtAfterPublishedAt()) { throw InvalidSurveyException() }
        require(isSectionIdsValid()) { throw InvalidSurveyException() }
    }
    
    /** 설문의 응답 순서가 유효한지, 응답이 각 섹션에 유효한지 확인하는 메서드 */
    fun validateResponse(surveyResponse: SurveyResponse) { /* 메서드 코드 */ }
    
    fun updateContent(/* 매개 변수들 */): Survey { /* 메서드 코드 */ }
    
    fun start(): Survey { /* 메서드 코드 */ }
    
    fun finish(): Survey { /* 메서드 코드 */ }
    
    // 그 외의 메서드들
}
```

`Survey` 클래스의 코드는 위와 같다. 특징은 아래와 같다.

1. `Survey` 클래스 생성 시 유효성 검증을 진행하여, 항상 유효한 `Survey` 클래스만 존재할 수 있도록 했다.
2. 설문과 관련된 기능을 전부 `Survey`에 모아두어 응집도가 상승하고, 재사용성이 향상되었다.
3. 불변 객체로 설계하여, 의도치 않은 객체의 변경을 막아 코드의 안정성이 향상되었다.

### ▶️ 설계 과정 성과 1 - 응집도 상승으로 인한 Service 계층의 복잡도 감소 & 유지 보수성 향상

설문이용에서 설문이 끝나는 경우는 **1. 추첨권이 소진**되거나, **2. 설문 마감일이 되는 경우**가 있다.

두 경우 다 동일하게 설문을 종료 상태로 업데이트 하는 기능이 필요하다.

이러한 기능을 **여러 Service 계층에 각자 구현**하게되면 아래와 같다.

![image](https://github.com/user-attachments/assets/92ba60d6-344a-4304-ae4a-2cab9769eb9b)

하지만 위의 경우, 설문 종료 로직을 수정하는 경우, 각 서비스의 설문 종료 코드를 수정해야한다. 즉 **수정 범위가 증가하게 되어 유지 보수가 어려워**진다.

하지만, **설문 종료 메서드를 Survey 클래스에 구현**하고, **각 Service 계층에서는 Survey 클래스의 메서드를 사용**한다면 어떨까? 이를 그림으로 표현하면 아래와 같다.

![image](https://github.com/user-attachments/assets/8ff596b3-cd29-4e57-8c3a-e83a213731c8)

위의 경우는 Service 계층에선 `Survey` 클래스의 메서드를 호출하기만 하면 되므로 **Service 계층의 복잡도가 감소**한다.

또한 설문 종료 로직을 수정하기 위해선 **Survey 클래스의 finish 메서드만 수정**하면 되고, 추후 설문 종료 기능이 필요한 곳이 생기면 **Survey 클래스의 finish 메서드를 재사용**하면 되므로 **유지 보수성이 향상**된다.

### ▶️ 설계 과정 성과 2 - Aggregate root를 설정하여 **설문 전체의 일관성을 유지**

![image](https://github.com/user-attachments/assets/b21eb693-56d6-465a-a091-43cc1669fbae)

설문이용에서는 위와 같이 선택지에 따라 다른 섹션으로 이동하도록 설정할 수 있다.

이러한 상황에서, 선택지에 따라 이동할 섹션을 존재하지 않는 섹션으로 수정한다면 어떻게 될까?

- DDD 미적용(라우팅 설정을 직접 수정 가능)
    - 설문 클래스를 거치지 않고 라우팅 설정을 직접 수정할 수 있으므로 존재하지 않는 섹션으로 수정 가능 → **설문 전체의 일관성이 깨짐**
- DDD 적용(Aggregate root를 통해서만 하위 객체 접근 가능)
    - 설문 클래스와 섹션 클래스를 거치면서 **변경하려는 섹션이 존재하는지 확인 가능**하므로 존재하지 않는 섹션으로 수정이 불가능 → **설문 전체의 일관성이 유지됨**

## 3️⃣ 설문 도메인 구현 과정 및 성과 (feat. TDD)

### ▶️ 어떻게 TDD 방식을 설문에 적용했는가?

![image](https://github.com/user-attachments/assets/e1480192-4cf4-49b2-a578-86087277bf69)

우리는 이전에 정리한 요구사항을 바탕으로 위와 같이 테스트 코드를 작성했다.

그리고, 테스트 코드가 통과하도록 최대한 빠르게 클래스의 메서드를 구현했다.

![image](https://github.com/user-attachments/assets/9f891b59-bead-4a46-beec-4ec63ca3e974)

이 과정에서, **테스트 코드 작성을 놓친 부분이 있는지 확인하기 위해 Jacoco를 통해 테스트 커버리지를 측정**하였고, domain 패키지의 테스트 커버리지를 100%로 달성하였다.

이후에는 테스트 커버리지를 100% 유지하면서 지속적으로 리팩토링을 진행하였다.

### ▶️ TDD 적용 성과 1 - 테스트 코드 작성으로 인한 기능 안정성 향상

domain 패키지의 테스트 커버리지를 100% 달성하여, 도메인 클래스의 메서드를 활용하는 서비스 코드의 안정성도 같이 향상되었다.

실제로 테스트 코드 작성 이후, 핵심 도메인 로직에 대한 버그 발생 빈도가 크게 줄었다.

### ▶️ TDD 적용 성과 2 - 리팩토링의 안정성 및 생산성 향상

리팩토링을 진행할 때 아무리 변경을 해도 테스트 코드를 통해 기존과 같은 동작을 한다는 것을 확인할 수 있어서 안정적이고 더 효율적으로 리팩토링을 진행할 수 있었다.

## 4️⃣ 리팩토링 과정 및 성과

앞서서 설문 도메인을 설계하고, 구현 까지 완료했지만 아래와 같은 이유로 리팩토링을 진행하기로 결정했다.

1. 설문 제작 시 어려움
2. 질문 추가에 대한 확장성 부족
3. 코드 로직의 복잡함(Null을 로직에 활용, 라우팅 방식에 대한 모호함, 가독성이 부족한 코드)

리팩토링 과정이 담긴 PR 링크

### ▶️ 리팩토링 결과

![image](https://github.com/user-attachments/assets/e0d93fea-6bfd-445c-b21f-b62b1f5f972e)

[**리팩토링 과정이 담긴 PR 링크**](https://github.com/SUIN-BUNDANG-LINE/Backend/pull/20)

[**리팩토링 후 설문 클래스 구조 설명 링크**](https://www.notion.so/f51d423cc3584357b3a2918927215720?pvs=21)

### ▶️ 리팩토링 성과 1 - 질문 인터페이스 세분화를 통한 확장성 증가

![image](https://github.com/user-attachments/assets/1b363d5a-2c69-4be7-8d4b-e3f1e7d5bb42)

기존에는 질문 인터페이스 하나와 질문 유형별 구현체의 구조였다.

하지만, 객관식 질문들의 공통 요구사항과 객관식 질문 중 선택지 기반 라우팅의 대상이 될 수 있는 단일 선택 질문에 대한 요구사항이 있는 등 **추후 질문 확장 시 코드 중복이 우려되어 세분화를 진행**했다.

이를 통해, 앞으로 주관식을 추가하면 TextQuestion 인터페이스 구현, 객관식을 추가하면 단일 선택이면 SingleChoiceQuestion, 다중 선택이면 MultipleChoiceQuestion 인터페이스를 구현하면 되므로 **질문 유형 추가에 대한 확장성이 증가**했다.

### ▶️ 리팩토링 성과 2 - sealed 클래스를 활용하여 가독성 및 유지보수성 향상

![image](https://github.com/user-attachments/assets/dc4cadb5-c149-4cb3-80a8-acff97273b18)

기존에는 기타 선택지를 null로 구분하였는데, 이 때 null의 의미가 모호하여 코드의 가독성이 떨어졌었다.

이제 sealed 클래스를 활용하여 명시적으로 기타 선택지임을 알 수 있어 더 유지보수와 가독성이 좋아졌다.

![image](https://github.com/user-attachments/assets/cd415036-7884-47aa-9400-f26a6711686b)

섹션 ID도 마찬가지로, 기존에는 마지막 섹션 ID를 Null로 구분하여 의미가 모호해서 코드의 가독성이 떨어졌었다.

이제 sealed 클래스를 활용하여 명시적으로 마지막 섹션 ID임을 알 수 있어 더 유지보수와 가독성이 좋아졌다.

## 5️⃣ 결론

이전 프로젝트들과 다르게 목표에 맞는 다양한 방법론을 도입하여 설계 & 개발을 진행하니까 다양한 장점을 경험할 수 있었다.

또한 이렇게 설계를 하고 개발을 진행해보니 이전 프로젝트에서 경험했던 다양한 문제점들을 덜 겪을 수 있어서 좋았다.
